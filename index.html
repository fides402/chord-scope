<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChordScope - Analizzatore di Accordi</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root { --bg: #0a0a0f; --surface: #14141f; --primary: #00ffc8; --secondary: #ff6b9d; --text: #e8e8f0; --text-muted: #6b6b80; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'IBM Plex Sans', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; padding: 24px; }
        header { text-align: center; margin-bottom: 32px; }
        .logo { font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 2rem; color: var(--primary); text-shadow: 0 0 20px rgba(0, 255, 200, 0.4); }
        .logo span { color: var(--secondary); }
        .subtitle { color: var(--text-muted); margin-top: 8px; }
        .upload-zone { background: var(--surface); border: 2px dashed rgba(0, 255, 200, 0.3); border-radius: 16px; padding: 48px; text-align: center; cursor: pointer; transition: all 0.3s ease; max-width: 600px; margin: 0 auto; }
        .upload-zone:hover { border-color: var(--primary); background: rgba(0, 255, 200, 0.05); }
        .upload-zone.hidden { display: none; }
        .file-input { display: none; }
        .results { max-width: 800px; margin: 0 auto; display: none; }
        .results.active { display: block; }
        .section { background: var(--surface); border-radius: 16px; padding: 24px; margin-bottom: 24px; }
        .section-title { font-family: 'JetBrains Mono', monospace; font-size: 1rem; color: var(--primary); margin-bottom: 16px; padding-bottom: 8px; border-bottom: 1px solid rgba(0, 255, 200, 0.2); }
        .chord-list { display: flex; flex-wrap: wrap; gap: 8px; }
        .chord-tag { font-family: 'JetBrains Mono', monospace; font-weight: 600; padding: 8px 16px; border-radius: 20px; background: rgba(0, 255, 200, 0.1); border: 1px solid rgba(0, 255, 200, 0.3); color: var(--primary); }
        .progression { font-family: 'JetBrains Mono', monospace; font-size: 1.4rem; letter-spacing: 2px; color: var(--secondary); word-break: break-all; }
        .progression-chord { display: inline-block; margin: 4px; padding: 8px 12px; background: rgba(255, 107, 157, 0.15); border-radius: 8px; }
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
        .stat-item { text-align: center; padding: 16px; background: rgba(0, 0, 0, 0.2); border-radius: 12px; }
        .stat-value { font-family: 'JetBrains Mono', monospace; font-size: 2rem; color: var(--primary); }
        .stat-label { font-size: 0.85rem; color: var(--text-muted); margin-top: 4px; }
        .key-display { font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; color: var(--secondary); text-align: center; padding: 16px; background: rgba(255, 107, 157, 0.1); border-radius: 12px; margin-bottom: 16px; }
        .loading-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 10, 15, 0.95); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .loading-overlay.active { opacity: 1; pointer-events: all; }
        .spinner { width: 60px; height: 60px; border: 3px solid rgba(0, 255, 200, 0.2); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 16px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { color: var(--text-muted); }
        .test-btn { background: var(--primary); color: var(--bg); border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; margin-top: 16px; }
    </style>
</head>
<body>
    <header>
        <div class="logo">Chord<span>Scope</span></div>
        <p class="subtitle">Analizzatore di accordi</p>
    </header>

    <div class="upload-zone" id="uploadZone">
        <p><strong>Trascina il file audio qui</strong></p>
        <p style="color: var(--text-muted); margin-top: 8px;">oppure clicca per selezionare</p>
        <p style="color: var(--text-muted); font-size: 0.85rem; margin-top: 16px;">Formati: MP3, WAV</p>
        <input type="file" class="file-input" id="fileInput" accept=".mp3,.wav,audio/mpeg,audio/wav">
        <button class="test-btn" onclick="loadTestFile()">Carica song.mp3</button>
    </div>

    <div class="results" id="results">
        <div class="section">
            <div class="key-display" id="keyDisplay">Tonalità: --</div>
            <div class="stats">
                <div class="stat-item"><div class="stat-value" id="totalChords">0</div><div class="stat-label">Accordi</div></div>
                <div class="stat-item"><div class="stat-value" id="uniqueChords">0</div><div class="stat-label">Unici</div></div>
                <div class="stat-item"><div class="stat-value" id="duration">0:00</div><div class="stat-label">Durata</div></div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">Progressione</div>
            <div class="progression" id="progression"></div>
        </div>
        <div class="section">
            <div class="section-title">Accordi</div>
            <div class="chord-list" id="chordList"></div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div style="text-align: center;"><div class="spinner"></div><div class="loading-text" id="loadingText">Analisi...</div></div>
    </div>

    <script>
        const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
        
        const CHORD = {
            'C':[1,0,0,0,1,0,0,1,0,0,0,0],'Cm':[1,0,0,1,0,0,0,1,0,0,0,0],
            'D':[0,0,1,0,0,0,1,0,0,1,0,0],'Dm':[0,0,1,0,0,1,0,0,0,1,0,0],
            'E':[0,0,0,0,1,0,0,0,1,0,0,1],'Em':[0,0,0,0,1,0,0,1,0,0,0,1],
            'F':[1,0,0,0,0,1,0,0,0,1,0,0],'Fm':[1,0,0,0,0,1,0,0,1,0,0,0],
            'G':[0,0,1,0,0,0,0,1,0,0,0,1],'Gm':[0,0,1,0,0,0,0,1,0,0,1,0],
            'A':[0,1,0,0,1,0,0,0,0,1,0,0],'Am':[1,0,0,0,1,0,0,0,0,1,0,0],
            'B':[0,0,0,1,0,0,1,0,0,0,0,1],'Bm':[0,0,1,0,0,0,1,0,0,0,0,1],
            'Bb':[0,0,1,0,0,1,0,0,0,0,1,0],'Bbm':[0,0,0,1,0,0,1,0,0,0,1,0],
            'Eb':[0,0,0,1,0,0,0,1,0,0,1,0],'Ebm':[0,0,0,1,0,0,0,1,0,0,1,0],
            'Ab':[1,0,0,1,0,0,0,0,1,0,0,0],'Abm':[0,0,0,1,0,0,0,0,1,0,0,1],
            'Db':[1,0,0,0,0,1,0,0,0,1,0,0],'Dbm':[0,1,0,0,0,0,1,0,0,0,1,0],
            'F#':[0,1,0,0,0,0,1,0,0,0,1,0],'F#m':[0,1,0,0,0,0,1,0,0,1,0,0],
            'C#':[0,1,0,0,0,1,0,0,1,0,0,0],'C#m':[0,1,0,0,1,0,0,0,1,0,0,0],
            'G#':[1,0,0,1,0,0,0,0,1,0,0,0],'G#m':[0,0,0,1,0,0,0,0,1,0,0,1],
            'G7':[0,0,1,0,0,0,0,1,0,0,0,1],'C7':[1,0,0,0,1,0,0,1,0,0,0,1],
            'D7':[0,0,1,0,0,0,1,0,0,1,0,0],'A7':[0,1,0,0,1,0,0,0,0,1,0,0],
            'E7':[0,0,0,0,1,0,0,1,0,0,1,0],'B7':[0,0,1,0,0,1,0,0,0,0,1,0],
            'F7':[1,0,0,0,0,1,0,0,1,0,0,0],'Bb7':[0,0,1,0,0,1,0,0,0,0,1,0],
            'Eb7':[0,0,0,1,0,0,0,1,0,0,1,0],'Ab7':[1,0,0,1,0,0,0,0,1,0,0,0],
            'Db7':[1,0,0,0,0,1,0,0,0,1,0,0],'Gb7':[0,1,0,0,0,0,1,0,0,0,1,0],
            'Cm7':[1,0,0,1,0,0,0,1,0,0,1,0],'Dm7':[0,0,1,0,0,1,0,0,1,0,0,0],
            'Em7':[0,0,0,0,1,0,0,1,0,0,1,0],'Fm7':[1,0,0,0,0,1,0,0,1,0,0,0],
            'Gm7':[0,0,1,0,0,0,0,1,0,0,1,0],'Am7':[1,0,0,0,1,0,0,0,0,1,0,0],
            'Bm7':[0,0,1,0,0,0,1,0,0,0,0,1]
        };

        const ALL = Object.keys(CHORD);

        const uZ = document.getElementById('uploadZone');
        const fI = document.getElementById('fileInput');
        const res = document.getElementById('results');
        const load = document.getElementById('loadingOverlay');
        const loadT = document.getElementById('loadingText');

        uZ.addEventListener('click', () => fI.click());
        uZ.addEventListener('dragover', e => { e.preventDefault(); uZ.style.borderColor = 'var(--primary)'; });
        uZ.addEventListener('dragleave', () => uZ.style.borderColor = '');
        uZ.addEventListener('drop', e => { e.preventDefault(); const f = e.dataTransfer.files[0]; if(f) process(f); });
        fI.addEventListener('change', e => { const f = e.target.files[0]; if(f) process(f); });

        function show(t) { loadT.textContent = t; load.classList.add('active'); }
        function hide() { load.classList.remove('active'); }

        async function loadTestFile() {
            show('Carico...');
            try {
                const response = await fetch('song.mp3');
                const arrayBuffer = await response.arrayBuffer();
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const buf = await ctx.decodeAudioData(arrayBuffer);
                show('Analizzo...');
                const result = analyze(buf);
                showResult(result, buf.duration);
                hide();
            } catch(e) { hide(); alert('Errore: '+e.message); }
        }

        async function process(file) {
            if (file.size > 50*1024*1024) { alert('Troppo grande'); return; }
            show('Carico...');
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const buf = await ctx.decodeAudioData(await file.arrayBuffer());
                show('Analizzo...');
                const result = analyze(buf);
                showResult(result, buf.duration);
                hide();
            } catch(e) { hide(); alert('Errore: '+e.message); }
        }

        function analyze(buf) {
            const data = buf.getChannelData(0);
            const sr = buf.sampleRate;
            const fft = 32768;
            const step = 16384;
            
            const votes = {};
            ALL.forEach(c => votes[c] = 0);
            let count = 0;
            
            for (let i = 0; i < data.length - fft; i += step) {
                const frame = data.slice(i, i + fft);
                const rms = Math.sqrt(frame.reduce((a,x)=>a+x*x,0)/fft);
                if (rms < 0.02) continue;
                
                const c = chroma(frame, sr);
                const mx = Math.max(...c);
                if (mx < 0.01) continue;
                const norm = c.map(x => x/mx);
                
                let best = null, bestS = -Infinity;
                for (const [name, t] of Object.entries(CHORD)) {
                    let s = 0;
                    for (let j = 0; j < 12; j++) if (t[j]) s += norm[j];
                    s /= t.filter(x=>x).length;
                    if (s > bestS) { bestS = s; best = name; }
                }
                
                if (bestS > 0.15) {
                    votes[best] = (votes[best] || 0) + 1;
                    count++;
                }
            }
            
            if (count === 0) return { key: 'Cm', chords: [] };
            
            const sorted = Object.entries(votes).sort((a,b) => b[1] - a[1]);
            
            const top = sorted.slice(0, 30).map(x => x[0]);
            
            const rootCounts = {};
            top.forEach(c => {
                const root = c.replace(/7|m7|dim|m/g, '');
                rootCounts[root] = (rootCounts[root] || 0) + 1;
            });
            
            let bestRoot = 'C';
            let bestRC = -1;
            for (const [r, c] of Object.entries(rootCounts)) {
                if (c > bestRC) { bestRC = c; bestRoot = r; }
            }
            
            const hasMinor = top.some(c => c.includes('m') && !c.includes('7'));
            const key = bestRoot + (hasMinor ? 'm' : '');
            
            const final = sorted.slice(0, 8).map(x => x[0]);
            
            return { key, chords: final };
        }

        function chroma(frame, sr) {
            const len = frame.length;
            const c = new Array(12).fill(0);
            
            const win = new Float32Array(len);
            for (let i = 0; i < len; i++) win[i] = 0.5 * (1 - Math.cos(2*Math.PI*i/(len-1)));
            
            const w = new Float32Array(len);
            for (let i = 0; i < len; i++) w[i] = frame[i] * win[i];
            
            const f = fft(w);
            const mag = new Float32Array(f.length/2);
            for (let i = 0; i < mag.length; i++) mag[i] = Math.sqrt(f[i].re*f[i].re + f[i].im*f[i].im);
            
            const minBin = Math.floor(40 * len / sr);
            const maxBin = Math.floor(600 * len / sr);
            
            for (let bin = minBin; bin < maxBin && bin < mag.length; bin++) {
                const freq = bin * sr / len;
                const note = 12 * Math.log2(freq / 440) + 69;
                const pc = ((Math.round(note) % 12) + 12) % 12;
                c[pc] += mag[bin];
            }
            
            const mx = Math.max(...c);
            if (mx > 0) for (let i = 0; i < 12; i++) c[i] /= mx;
            return c;
        }

        function fft(sig) {
            const len = sig.length;
            const f = new Array(len);
            for (let i = 0; i < len; i++) f[i] = { re: sig[i], im: 0 };
            
            const bits = Math.log2(len);
            for (let i = 0; i < len; i++) {
                const j = parseInt(i.toString(2).split('').reverse().join(''), 2);
                if (j > i) [f[i], f[j]] = [f[j], f[i]];
            }
            
            for (let size = 2; size <= len; size *= 2) {
                const half = size / 2;
                const ang = -2 * Math.PI / size;
                const wr = Math.cos(ang), wi = Math.sin(ang);
                for (let i = 0; i < len; i += size) {
                    let cr = 1, ci = 0;
                    for (let j = 0; j < half; j++) {
                        const k = i + j, l = k + half;
                        const tr = cr * f[l].re - ci * f[l].im;
                        const ti = cr * f[l].im + ci * f[l].re;
                        f[l].re = f[k].re - tr; f[l].im = f[k].im - ti;
                        f[k].re += tr; f[k].im += ti;
                        const nr = cr * wr - ci * wi;
                        ci = cr * wi + ci * wr;
                        cr = nr;
                    }
                }
            }
            return f;
        }

        function showResult(r, dur) {
            uZ.classList.add('hidden');
            res.classList.add('active');
            document.getElementById('keyDisplay').textContent = 'Tonalità: ' + r.key;
            document.getElementById('totalChords').textContent = r.chords.length;
            document.getElementById('uniqueChords').textContent = r.chords.length;
            document.getElementById('duration').textContent = Math.floor(dur/60) + ':' + Math.floor(dur%60).toString().padStart(2,'0');
            document.getElementById('chordList').innerHTML = r.chords.map(c => '<span class="chord-tag">' + c + '</span>').join('');
            document.getElementById('progression').innerHTML = r.chords.map(c => '<span class="progression-chord">' + c + '</span>').join(' → ');
        }
    </script>
</body>
</html>
