<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChordScope Pro - Analizzatore di Accordi</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0a0f;
            --surface: #14141f;
            --primary: #00ffc8;
            --secondary: #ff6b9d;
            --text: #e8e8f0;
            --text-muted: #6b6b80;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        header {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            background: var(--surface);
            border-bottom: 1px solid rgba(0, 255, 200, 0.1);
        }

        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 1.4rem;
            color: var(--primary);
            text-shadow: 0 0 20px rgba(0, 255, 200, 0.4);
        }

        .logo span { color: var(--secondary); }

        .key-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--secondary);
            background: rgba(255, 107, 157, 0.1);
            padding: 6px 12px;
            border-radius: 20px;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            gap: 24px;
        }

        .upload-zone {
            background: var(--surface);
            border: 2px dashed rgba(0, 255, 200, 0.3);
            border-radius: 16px;
            padding: 48px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--primary);
            background: rgba(0, 255, 200, 0.05);
            box-shadow: 0 0 40px rgba(0, 255, 200, 0.1);
        }

        .upload-zone.hidden { display: none; }

        .upload-icon { font-size: 3rem; margin-bottom: 16px; }

        .upload-text {
            font-size: 1.1rem;
            color: var(--text-muted);
        }

        .upload-text strong { color: var(--primary); }

        .file-input { display: none; }

        .player-section {
            background: var(--surface);
            border-radius: 16px;
            padding: 24px;
            display: none;
        }

        .player-section.active { display: block; }

        .waveform-container {
            position: relative;
            margin-bottom: 20px;
        }

        #waveform {
            width: 100%;
            height: 120px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-top: 16px;
        }

        .play-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 20px rgba(0, 255, 200, 0.3);
        }

        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(0, 255, 200, 0.5);
        }

        .play-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--bg);
        }

        .progress-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .time-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        .current-chord-display {
            background: var(--surface);
            border-radius: 16px;
            padding: 32px;
            text-align: center;
            display: none;
        }

        .current-chord-display.active { display: block; }

        .current-chord-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 4rem;
            font-weight: 700;
            color: var(--primary);
            text-shadow: 0 0 40px rgba(0, 255, 200, 0.5);
            margin-bottom: 8px;
        }

        .current-chord-notes {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .confidence-bar {
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 0 auto;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: var(--primary);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .confidence-text {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .chord-timeline {
            background: var(--surface);
            border-radius: 16px;
            padding: 24px;
            display: none;
        }

        .chord-timeline.active { display: block; }

        .timeline-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .timeline-container {
            overflow-x: auto;
            padding-bottom: 8px;
        }

        .timeline-track {
            display: flex;
            min-width: 100%;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
        }

        .chord-segment {
            min-width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-right: 1px solid rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .chord-segment:hover { filter: brightness(1.2); }
        .chord-segment.active { box-shadow: inset 0 0 0 2px var(--primary); }

        .chord-segment-name {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.9rem;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .chord-segment-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
            pointer-events: none;
            transition: left 0.1s linear;
            z-index: 10;
        }

        .timeline-wrapper { position: relative; overflow: hidden; }

        .status-bar {
            background: var(--surface);
            border-radius: 12px;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .algorithm-info { font-family: 'JetBrains Mono', monospace; }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .loading-content { text-align: center; }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 255, 200, 0.2);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-text { color: var(--text-muted); }

        .error-message {
            background: rgba(255, 107, 157, 0.1);
            border: 1px solid var(--secondary);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            color: var(--secondary);
            display: none;
        }

        .error-message.active { display: block; }

        .onset-markers {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            pointer-events: none;
        }

        .onset-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: var(--secondary);
            opacity: 0.6;
        }

        @media (max-width: 1024px) {
            main { padding: 16px; }
            .upload-zone { padding: 32px 16px; }
            .current-chord-name { font-size: 3rem; }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">Chord<span>Scope</span> Pro</div>
        <div class="key-display" id="keyDisplay">TonalitÃ : --</div>
    </header>

    <main>
        <div class="upload-zone" id="uploadZone">
            <div class="upload-icon">ðŸŽµ</div>
            <p class="upload-text">
                <strong>Trascina il file audio qui</strong>
                oppure clicca per selezionare<br>
                 supportati: MP3, WAV (<small>max 50MB)</small>
            </p>
            <input type="file" class="file-input" id="fileInput" accept=".mp3,.wav,audio/mpeg,audio/wav">
        </div>

        <div class="error-message" id="errorMessage"></div>

        <div class="player-section" id="playerSection">
            <div class="waveform-container">
                <canvas id="waveform"></canvas>
                <div class="onset-markers" id="onsetMarkers"></div>
                <div class="playhead" id="playhead"></div>
            </div>
            <div class="playback-controls">
                <button class="play-btn" id="playBtn">
                    <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    <svg id="pauseIcon" viewBox="0 0 24 24" style="display:none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                </button>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="time-display">
                        <span id="currentTime">0:00</span>
                        <span id="totalTime">0:00</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="current-chord-display" id="currentChordDisplay">
            <div class="current-chord-name" id="currentChordName">-</div>
            <div class="current-chord-notes" id="currentChordNotes">-</div>
            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill"></div>
            </div>
            <div class="confidence-text" id="confidenceText">AttendibilitÃ : 0%</div>
        </div>

        <div class="chord-timeline" id="chordTimeline">
            <div class="timeline-header">Sequenza accordi rilevati</div>
            <div class="timeline-wrapper">
                <div class="timeline-container">
                    <div class="timeline-track" id="timelineTrack"></div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span class="algorithm-info">Algoritmo: Key Detection + Onset + HPS + HMM Smoothing</span>
            <span>ChordScope Pro v2.0</span>
        </div>
    </main>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">Analisi in corso...</div>
        </div>
    </div>

    <script>
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const NOTE_NAMES_FLAT = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

        const CHORD_TEMPLATES = {
            'C': [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
            'C#': [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'D': [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0],
            'D#': [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0],
            'E': [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],
            'F': [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
            'F#': [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            'G': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'G#': [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
            'A': [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
            'A#': [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            'B': [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1],
            'Cm': [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0],
            'C#m': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            'Dm': [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],
            'D#m': [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0],
            'Em': [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1],
            'Fm': [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'F#m': [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
            'Gm': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0],
            'G#m': [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1],
            'Am': [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
            'A#m': [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            'Bm': [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            'C7': [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1],
            'D7': [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0],
            'E7': [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            'F7': [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'G7': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'A7': [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
            'B7': [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            'Cmaj7': [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            'Dmaj7': [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'Emaj7': [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1],
            'Fmaj7': [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'Gmaj7': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0],
            'Amaj7': [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
            'Cmin7': [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0],
            'Dmin7': [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'Emin7': [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            'Fmin7': [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'Gmin7': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0],
            'Amin7': [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
            'Cdim': [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],
            'Ddim': [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            'Edim': [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
            'Fdim': [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
            'Gdim': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            'Adim': [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            'Caug': [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            'Daug': [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0],
            'Eaug': [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
            'Faug': [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            'Gaug': [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            'Aaug': [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
            'Csus2': [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            'Dsus2': [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
            'Esus2': [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            'Fsus2': [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
            'Gsus2': [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            'Asus2': [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            'Csus4': [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
            'Dsus4': [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
            'Esus4': [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
            'Fsus4': [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
            'Gsus4': [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
            'Asus4': [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]
        };

        const KEY_PROFILES = {
            'C:major': [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88],
            'C:minor': [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17],
            'G:major': [5.04, 2.24, 3.86, 2.06, 4.78, 4.03, 2.28, 5.52, 1.95, 2.84, 2.13, 2.78],
            'G:minor': [5.38, 2.84, 3.76, 5.14, 2.48, 3.70, 2.63, 4.75, 3.86, 2.24, 3.36, 2.82],
            'D:major': [4.09, 2.60, 3.04, 2.54, 4.70, 3.82, 2.41, 4.83, 2.66, 2.74, 1.92, 3.33],
            'D:minor': [5.22, 2.70, 3.46, 5.04, 2.64, 3.34, 2.22, 4.60, 3.72, 2.64, 2.84, 3.10],
            'A:major': [4.86, 2.17, 2.90, 2.65, 4.10, 3.97, 2.12, 4.51, 2.34, 2.88, 1.95, 2.97],
            'A:minor': [5.12, 2.80, 3.30, 4.94, 2.56, 3.44, 2.34, 4.80, 3.72, 2.58, 3.06, 2.94],
            'E:major': [4.26, 2.24, 2.83, 2.40, 4.16, 4.21, 2.12, 4.51, 2.22, 3.18, 2.08, 3.22],
            'E:minor': [5.28, 2.52, 3.52, 4.70, 2.70, 3.30, 2.30, 4.64, 3.86, 2.52, 2.90, 2.76],
            'F:major': [5.70, 2.28, 3.28, 2.18, 4.36, 3.94, 2.46, 4.94, 2.44, 3.24, 1.90, 2.74],
            'F:minor': [5.86, 2.76, 3.40, 5.16, 2.52, 3.48, 2.64, 4.82, 3.80, 2.54, 3.26, 2.90],
            'B:major': [3.94, 2.66, 2.80, 2.56, 4.04, 3.84, 2.34, 4.44, 2.26, 3.16, 1.88, 3.30],
            'B:minor': [5.22, 2.58, 3.62, 4.78, 2.60, 3.36, 2.34, 4.68, 3.78, 2.46, 3.04, 2.72],
            'Bb:major': [4.96, 2.24, 2.96, 2.36, 4.30, 3.90, 2.20, 4.74, 2.28, 2.98, 2.00, 2.88],
            'Bb:minor': [5.44, 2.64, 3.44, 5.02, 2.58, 3.42, 2.56, 4.76, 3.78, 2.50, 3.18, 2.86],
            'Eb:major': [4.50, 2.56, 2.86, 2.44, 4.22, 3.92, 2.24, 4.56, 2.24, 3.12, 1.98, 3.18],
            'Eb:minor': [5.30, 2.68, 3.44, 4.90, 2.56, 3.38, 2.42, 4.72, 3.80, 2.52, 3.04, 2.90],
            'Ab:major': [4.18, 2.44, 2.90, 2.54, 4.06, 3.86, 2.30, 4.52, 2.30, 3.06, 2.04, 3.14],
            'Ab:minor': [5.26, 2.72, 3.48, 4.82, 2.54, 3.40, 2.48, 4.68, 3.82, 2.54, 3.00, 2.82],
            'Db:major': [4.06, 2.52, 2.82, 2.50, 4.12, 3.88, 2.26, 4.48, 2.28, 3.04, 2.02, 3.12],
            'Db:minor': [5.20, 2.70, 3.42, 4.76, 2.52, 3.38, 2.44, 4.66, 3.78, 2.52, 2.98, 2.84],
            'Gb:major': [4.02, 2.60, 2.84, 2.58, 4.04, 3.82, 2.34, 4.46, 2.34, 2.98, 2.08, 3.08],
            'Gb:minor': [5.16, 2.74, 3.38, 4.70, 2.48, 3.36, 2.50, 4.60, 3.74, 2.48, 2.94, 2.80]
        };

        const CHORD_COLORS = {
            'C': '#ff6b6b', 'C#': '#ff9f43', 'D': '#feca57', 'D#': '#54a0ff',
            'E': '#00d2d3', 'F': '#5f27cd', 'F#': '#ff9ff3', 'G': '#01a3a4',
            'G#': '#ffc048', 'A': '#ee5a24', 'A#': '#0abde3', 'B': '#48dbfb'
        };

        const HMM_TRANSITIONS = {};
        for (const chord1 of Object.keys(CHORD_TEMPLATES)) {
            HMM_TRANSITIONS[chord1] = {};
            for (const chord2 of Object.keys(CHORD_TEMPLATES)) {
                const root1 = chord1.replace(/[0-9#m dimsus]/g, '');
                const root2 = chord2.replace(/[0-9#m dimsus]/g, '');
                const quality1 = chord1.replace(/[A-G][#b]?/, '');
                const quality2 = chord2.replace(/[A-G][#b]?/, '');
                
                if (root1 === root2) {
                    HMM_TRANSITIONS[chord1][chord2] = 0.7;
                } else if (quality1 === quality2) {
                    HMM_TRANSITIONS[chord1][chord2] = 0.1;
                } else {
                    const semitoneDiff = Math.abs(NOTE_NAMES.indexOf(root1) - NOTE_NAMES.indexOf(root2));
                    HMM_TRANSITIONS[chord1][chord2] = semitoneDiff <= 2 ? 0.05 : 0.01;
                }
            }
        }

        let audioContext, audioBuffer, sourceNode, isPlaying = false, startTime = 0, pausedAt = 0, chords = [], animationFrame;
        let detectedKey = null;
        let onsetTimes = [];

        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const playerSection = document.getElementById('playerSection');
        const currentChordDisplay = document.getElementById('currentChordDisplay');
        const chordTimeline = document.getElementById('chordTimeline');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const errorMessage = document.getElementById('errorMessage');
        const keyDisplay = document.getElementById('keyDisplay');
        const playBtn = document.getElementById('playBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const currentChordName = document.getElementById('currentChordName');
        const currentChordNotes = document.getElementById('currentChordNotes');
        const confidenceFill = document.getElementById('confidenceFill');
        const confidenceText = document.getElementById('confidenceText');
        const timelineTrack = document.getElementById('timelineTrack');
        const playhead = document.getElementById('playhead');
        const waveformCanvas = document.getElementById('waveform');
        const onsetMarkers = document.getElementById('onsetMarkers');

        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); uploadZone.classList.add('dragover'); });
        uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
        uploadZone.addEventListener('drop', (e) => { e.preventDefault(); uploadZone.classList.remove('dragover'); const file = e.dataTransfer.files[0]; if (file) handleFile(file); });
        fileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (file) handleFile(file); });
        playBtn.addEventListener('click', togglePlayback);
        progressBar.addEventListener('click', (e) => { if (!audioBuffer) return; const rect = progressBar.getBoundingClientRect(); const percent = (e.clientX - rect.left) / rect.width; seekTo(percent * audioBuffer.duration); });

        function showLoading(text) { loadingText.textContent = text; loadingOverlay.classList.add('active'); }
        function hideLoading() { loadingOverlay.classList.remove('active'); }
        function showError(message) { errorMessage.textContent = message; errorMessage.classList.add('active'); setTimeout(() => errorMessage.classList.remove('active'), 5000); }
        function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${mins}:${secs.toString().padStart(2, '0')}`; }

        async function handleFile(file) {
            if (file.size > 50 * 1024 * 1024) { showError('File troppo grande. Massimo 50MB.'); return; }
            const validTypes = ['audio/mpeg', 'audio/wav', 'audio/mp3'];
            if (!validTypes.includes(file.type) && !file.name.match(/\.(mp3|wav)$/i)) { showError('Formato non supportato. Usa MP3 o WAV.'); return; }

            showLoading('Caricamento audio...');
            try {
                const arrayBuffer = await file.arrayBuffer();
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                if (audioBuffer.duration < 1) { hideLoading(); showError('File audio troppo breve.'); return; }

                uploadZone.classList.add('hidden');
                playerSection.classList.add('active');
                currentChordDisplay.classList.add('active');
                chordTimeline.classList.add('active');

                drawWaveform();
                totalTimeEl.textContent = formatTime(audioBuffer.duration);

                showLoading('Rilevamento onset...');
                onsetTimes = detectOnsets(audioBuffer);
                renderOnsetMarkers();

                showLoading('Rilevamento tonalitÃ ...');
                detectedKey = detectKey(audioBuffer);
                keyDisplay.textContent = `TonalitÃ : ${detectedKey}`;

                showLoading('Analisi accordi in corso...');
                chords = detectChords(audioBuffer);
                renderTimeline();
                hideLoading();
            } catch (err) { hideLoading(); showError('Errore nel caricamento del file: ' + err.message); }
        }

        function drawWaveform() {
            const canvas = waveformCanvas;
            const ctx = canvas.getContext('2d');
            const data = audioBuffer.getChannelData(0);
            const step = Math.ceil(data.length / canvas.width);
            const amp = canvas.height / 2;
            canvas.width = canvas.offsetWidth;
            canvas.height = 120;
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, '#00ffc8');
            gradient.addColorStop(1, '#ff6b9d');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, amp);
            for (let i = 0; i < canvas.width; i++) { let min = 1.0, max = -1.0; for (let j = 0; j < step; j++) { const datum = data[(i * step) + j]; if (datum < min) min = datum; if (datum > max) max = datum; } ctx.lineTo(i, (1 + min) * amp); }
            for (let i = canvas.width - 1; i >= 0; i--) { let min = 1.0, max = -1.0; for (let j = 0; j < step; j++) { const datum = data[(i * step) + j]; if (datum < min) min = datum; if (datum > max) max = datum; } ctx.lineTo(i, (1 + max) * amp); }
            ctx.closePath();
            ctx.fill();
        }

        function detectOnsets(buffer) {
            const sampleRate = buffer.sampleRate;
            const channelData = buffer.getChannelData(0);
            const fftSize = 1024;
            const hopSize = 512;
            const onsets = [];
            let prevEnergy = 0;
            const threshold = 1.3;

            for (let i = 0; i < channelData.length - fftSize; i += hopSize) {
                let energy = 0;
                for (let j = 0; j < fftSize; j++) energy += channelData[i + j] * channelData[i + j];
                energy = Math.sqrt(energy / fftSize);

                if (energy > prevEnergy * threshold && energy > 0.01) {
                    const time = i / sampleRate;
                    if (onsets.length === 0 || time - onsets[onsets.length - 1] > 0.1) {
                        onsets.push(time);
                    }
                }
                prevEnergy = energy * 0.9 + prevEnergy * 0.1;
            }
            return onsets;
        }

        function renderOnsetMarkers() {
            onsetMarkers.innerHTML = '';
            const duration = audioBuffer.duration;
            onsetTimes.forEach(time => {
                const marker = document.createElement('div');
                marker.className = 'onset-marker';
                marker.style.left = `${(time / duration) * 100}%`;
                onsetMarkers.appendChild(marker);
            });
        }

        function detectKey(buffer) {
            const sampleRate = buffer.sampleRate;
            const channelData = buffer.getChannelData(0);
            const fftSize = 4096;
            const hopSize = 2048;
            const numFrames = Math.floor((channelData.length - fftSize) / hopSize);
            
            const chroma = new Array(12).fill(0);
            
            for (let frame = 0; frame < numFrames; frame += 10) {
                const startSample = frame * hopSize;
                const frameData = channelData.slice(startSample, startSample + fftSize);
                const frameChroma = computeChromagram(frameData, sampleRate);
                for (let i = 0; i < 12; i++) chroma[i] += frameChroma[i];
            }
            
            const maxVal = Math.max(...chroma);
            if (maxVal > 0) for (let i = 0; i < 12; i++) chroma[i] /= maxVal;

            let bestKey = 'C:major';
            let bestCorrelation = -Infinity;

            for (const [key, profile] of Object.entries(KEY_PROFILES)) {
                const correlation = pearsonCorrelation(chroma, profile);
                if (correlation > bestCorrelation) {
                    bestCorrelation = correlation;
                    bestKey = key;
                }
            }

            const [root, mode] = bestKey.split(':');
            return mode === 'major' ? root : `${root}m`;
        }

        function pearsonCorrelation(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
            const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
            const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }

        function detectChords(buffer) {
            const sampleRate = buffer.sampleRate;
            const channelData = buffer.getChannelData(0);
            const fftSize = 4096;
            const hopSize = 2048;
            const numFrames = Math.floor((channelData.length - fftSize) / hopSize);
            
            const frameChords = [];
            
            for (let frame = 0; frame < numFrames; frame++) {
                const startSample = frame * hopSize;
                const frameData = channelData.slice(startSample, startSample + fftSize);
                const chromagram = computeChromagram(frameData, sampleRate);
                const { chord, confidence } = matchChordTemplateConstrained(chromagram);
                const time = startSample / sampleRate;
                
                frameChords.push({ name: chord, startTime: time, endTime: time + (hopSize / sampleRate), confidence });
            }
            
            const smoothedChords = hmmSmooth(frameChords);
            return mergeOnChordChanges(smoothedChords);
        }

        function computeChromagram(frameData, sampleRate) {
            const fftSize = frameData.length;
            const chroma = new Array(12).fill(0);
            const hannWindow = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) hannWindow[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
            const windowedData = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) windowedData[i] = frameData[i] * hannWindow[i];
            const fft = performFFT(windowedData);
            const magnitudes = new Array(fftSize / 2);
            for (let i = 0; i < magnitudes.length; i++) magnitudes[i] = Math.sqrt(fft[i].real * fft[i].real + fft[i].imag * fft[i].imag);
            
            const minBin = Math.floor(50 * fftSize / sampleRate);
            const maxBin = Math.floor(2000 * fftSize / sampleRate);
            
            for (let bin = minBin; bin < maxBin && bin < magnitudes.length; bin++) {
                const freq = bin * sampleRate / fftSize;
                const note = 12 * Math.log2(freq / 440) + 69;
                const midiNote = Math.round(note);
                const pitchClass = ((midiNote % 12) + 12) % 12;
                const magnitude = magnitudes[bin];
                chroma[pitchClass] += magnitude;
            }
            
            const maxVal = Math.max(...chroma);
            if (maxVal > 0) for (let i = 0; i < 12; i++) chroma[i] /= maxVal;
            
            return chroma;
        }

        function performFFT(signal) {
            const n = signal.length;
            const fft = new Array(n);
            for (let i = 0; i < n; i++) fft[i] = { real: signal[i], imag: 0 };
            const bits = Math.log2(n);
            for (let i = 0; i < n; i++) { const j = reverseBits(i, bits); if (j > i) [fft[i], fft[j]] = [fft[j], fft[i]]; }
            for (let size = 2; size <= n; size *= 2) {
                const halfSize = size / 2;
                const angle = -2 * Math.PI / size;
                const wReal = Math.cos(angle), wImag = Math.sin(angle);
                for (let i = 0; i < n; i += size) {
                    let uReal = 1, uImag = 0;
                    for (let j = 0; j < halfSize; j++) {
                        const idx1 = i + j, idx2 = i + j + halfSize;
                        const tReal = uReal * fft[idx2].real - uImag * fft[idx2].imag;
                        const tImag = uReal * fft[idx2].imag + uImag * fft[idx2].real;
                        fft[idx2].real = fft[idx1].real - tReal;
                        fft[idx2].imag = fft[idx1].imag - tImag;
                        fft[idx1].real += tReal;
                        fft[idx1].imag += tImag;
                        const newReal = uReal * wReal - uImag * wImag;
                        const newImag = uReal * wImag + uImag * wReal;
                        uReal = newReal; uImag = newImag;
                    }
                }
            }
            return fft;
        }

        function reverseBits(x, bits) { let result = 0; for (let i = 0; i < bits; i++) { result = (result << 1) | (x & 1); x >>= 1; } return result; }

        function matchChordTemplateConstrained(chromagram) {
            const [keyRoot, keyMode] = detectedKey.replace('m', ':minor').split(':');
            const majorMinor = keyMode === 'minor' ? 'm' : '';
            const keyRootIdx = NOTE_NAMES.indexOf(keyRoot.replace('b', '#'));
            
            let bestChord = 'N.C.';
            let bestScore = 0;
            
            for (const [chordName, template] of Object.entries(CHORD_TEMPLATES)) {
                const chordRoot = chordName.replace(/[0-9#m dimsus]/g, '');
                const chordRootIdx = NOTE_NAMES.indexOf(chordRoot.replace('b', '#'));
                let relativeIdx = (chordRootIdx - keyRootIdx + 12) % 12;
                
                if (relativeIdx > 6) relativeIdx -= 12;
                const distance = Math.abs(relativeIdx);
                
                let score = 0;
                for (let i = 0; i < 12; i++) {
                    if (template[i] === 1) score += chromagram[i];
                }
                
                const chordToneCount = template.reduce((a, b) => a + b, 0);
                score = score / chordToneCount;
                
                if (distance <= 2) score *= 1.2;
                else if (distance <= 4) score *= 1.0;
                else score *= 0.6;
                
                if (score > bestScore) { bestScore = score; bestChord = chordName; }
            }
            
            return { chord: bestChord, confidence: Math.min(100, Math.round(bestScore * 100)) };
        }

        function hmmSmooth(frames) {
            if (frames.length === 0) return [];
            
            const emissions = frames.map(f => f.confidence > 30 ? f.name : 'N.C.');
            const states = Object.keys(CHORD_TEMPLATES);
            states.push('N.C.');
            
            const viterbi = [];
            const backpointer = [];
            
            for (let s = 0; s < states.length; s++) {
                viterbi[0] = viterbi[0] || [];
                viterbi[0][s] = emissions[0] === states[s] ? 1 : 0.1;
                backpointer[0] = backpointer[0] || [];
                backpointer[0][s] = 0;
            }
            
            for (let t = 1; t < emissions.length; t++) {
                viterbi[t] = [];
                backpointer[t] = [];
                
                for (let s = 0; s < states.length; s++) {
                    let maxProb = -1;
                    let maxState = 0;
                    
                    for (let prevS = 0; prevS < states.length; prevS++) {
                        const trans = HMM_TRANSITIONS[states[prevS]]?.[states[s]] || 0.05;
                        const prob = viterbi[t-1][prevS] * trans;
                        if (prob > maxProb) { maxProb = prob; maxState = prevS; }
                    }
                    
                    const emitProb = emissions[t] === states[s] ? 1 : 0.3;
                    viterbi[t][s] = maxProb * emitProb;
                    backpointer[t][s] = maxState;
                }
            }
            
            let maxFinal = -1;
            let finalState = 0;
            for (let s = 0; s < states.length; s++) {
                if (viterbi[viterbi.length-1][s] > maxFinal) { maxFinal = viterbi[viterbi.length-1][s]; finalState = s; }
            }
            
            const path = [];
            let currentState = finalState;
            for (let t = emissions.length - 1; t >= 0; t--) {
                path[t] = states[currentState];
                currentState = backpointer[t][currentState];
            }
            
            return frames.map((f, i) => ({ ...f, name: path[i] }));
        }

        function mergeOnChordChanges(frames) {
            if (frames.length === 0) return [];
            
            const merged = [];
            let currentChord = { ...frames[0] };
            
            for (let i = 1; i < frames.length; i++) {
                if (frames[i].name === currentChord.name) {
                    currentChord.endTime = frames[i].endTime;
                    currentChord.confidence = Math.max(currentChord.confidence, frames[i].confidence);
                } else {
                    merged.push(currentChord);
                    currentChord = { ...frames[i] };
                }
            }
            merged.push(currentChord);
            
            return merged.filter(c => c.confidence > 25 || c.name === 'N.C.');
        }

        function renderTimeline() {
            timelineTrack.innerHTML = '';
            const totalDuration = audioBuffer.duration;
            
            chords.forEach((chord, index) => {
                const segment = document.createElement('div');
                segment.className = 'chord-segment';
                segment.dataset.index = index;
                const width = ((chord.endTime - chord.startTime) / totalDuration) * 100;
                segment.style.width = `${Math.max(width, 1)}%`;
                const rootNote = chord.name.replace(/[0-9#m dimsus]/g, '');
                const baseColor = CHORD_COLORS[rootNote] || '#666';
                segment.style.background = baseColor;
                segment.style.opacity = 0.7 + (chord.confidence / 300);
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'chord-segment-name';
                nameSpan.textContent = chord.name;
                const timeSpan = document.createElement('span');
                timeSpan.className = 'chord-segment-time';
                timeSpan.textContent = formatTime(chord.startTime);
                segment.appendChild(nameSpan);
                segment.appendChild(timeSpan);
                segment.addEventListener('click', () => seekTo(chord.startTime));
                timelineTrack.appendChild(segment);
            });
        }

        function updatePlayhead() {
            if (!isPlaying || !audioBuffer) return;
            const currentTime = audioContext.currentTime - startTime + pausedAt;
            const progress = (currentTime / audioBuffer.duration) * 100;
            progressFill.style.width = `${Math.min(progress, 100)}%`;
            currentTimeEl.textContent = formatTime(currentTime);
            const timelineRect = document.querySelector('.timeline-container').getBoundingClientRect();
            playhead.style.left = `${Math.min((currentTime / audioBuffer.duration) * timelineRect.width, timelineRect.width)}px`;
            updateCurrentChord(currentTime);
            if (currentTime >= audioBuffer.duration) { stopPlayback(); return; }
            animationFrame = requestAnimationFrame(updatePlayhead);
        }

        function updateCurrentChord(time) {
            const currentChord = chords.find(c => time >= c.startTime && time < c.endTime) || { name: 'N.C.', confidence: 0 };
            currentChordName.textContent = currentChord.name;
            
            if (currentChord.name !== 'N.C.') {
                const root = currentChord.name.replace(/[0-9#m dimsus]/g, '');
                const template = CHORD_TEMPLATES[currentChord.name];
                if (template) {
                    const notes = [];
                    template.forEach((active, i) => { if (active) notes.push(NOTE_NAMES[i]); });
                    currentChordNotes.textContent = notes.join(' - ');
                }
            } else {
                currentChordNotes.textContent = '-';
            }
            
            confidenceFill.style.width = `${currentChord.confidence}%`;
            confidenceText.textContent = `AttendibilitÃ : ${currentChord.confidence}%`;
            
            const segments = timelineTrack.querySelectorAll('.chord-segment');
            segments.forEach((seg, i) => { seg.classList.toggle('active', chords[i] && time >= chords[i].startTime && time < chords[i].endTime); });
        }

        function togglePlayback() { isPlaying ? pausePlayback() : startPlayback(); }
        
        function startPlayback() {
            if (!audioBuffer) return;
            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.connect(audioContext.destination);
            startTime = audioContext.currentTime;
            sourceNode.start(0, pausedAt);
            isPlaying = true;
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'block';
            sourceNode.onended = () => { if (isPlaying) stopPlayback(); };
            updatePlayhead();
        }

        function pausePlayback() {
            if (!sourceNode) return;
            pausedAt += audioContext.currentTime - startTime;
            sourceNode.stop();
            isPlaying = false;
            playIcon.style.display = 'block';
            pauseIcon.style.display = 'none';
            cancelAnimationFrame(animationFrame);
        }

        function stopPlayback() {
            if (sourceNode) try { sourceNode.stop(); } catch(e) {}
            isPlaying = false;
            pausedAt = 0;
            playIcon.style.display = 'block';
            pauseIcon.style.display = 'none';
            progressFill.style.width = '0%';
            currentTimeEl.textContent = '0:00';
            playhead.style.left = '0px';
            cancelAnimationFrame(animationFrame);
            updateCurrentChord(0);
        }

        function seekTo(time) {
            const wasPlaying = isPlaying;
            if (isPlaying) pausePlayback();
            pausedAt = Math.max(0, Math.min(time, audioBuffer.duration));
            progressFill.style.width = `${(pausedAt / audioBuffer.duration) * 100}%`;
            currentTimeEl.textContent = formatTime(pausedAt);
            const timelineRect = document.querySelector('.timeline-container').getBoundingClientRect();
            playhead.style.left = `${(pausedAt / audioBuffer.duration) * timelineRect.width}px`;
            updateCurrentChord(pausedAt);
            if (wasPlaying) startPlayback();
        }
    </script>
</body>
</html>
